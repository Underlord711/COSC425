<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Weighted Undirected Graph Generator</title>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.21.0/cytoscape.min.js"></script>
	<script src="https://cdn.tailwindcss.com"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<link rel="stylesheet" href="css/matrix.css">

</head>

<body class="bg-gray-100 p-6">
	<div class="max-w-4xl mx-auto bg-white p-6 rounded-lg shadow-md">
		<h1 class="text-2xl font-bold mb-4">Weighted Undirected Graph Generator</h1>

		<div class="space-y-4">
			<div>
				<label for="numVertices" class="block text-sm font-medium">Number of Vertices:</label>
				<input type="number" id="numVertices" value="10" min="4" required
					class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm p-2">
			</div>

			<div>
				<label for="weight1" class="block text-sm font-medium">Weight for Edge Type 1:</label>
				<input type="number" id="weight1" value="0.2" required
					class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm p-2">
			</div>

			<div>
				<label for="weight2" class="block text-sm font-medium">Weight for Edge Type 2:</label>
				<input type="number" id="weight2" value="0.7" required
					class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm p-2">
			</div>

			<div class="space-x-4">
				<button onclick="generateGraph()"
					class="bg-indigo-500 text-white px-4 py-2 rounded hover:bg-indigo-600 focus:outline-none">Generate
					Graph</button>
				<button onclick="toggleMatrix()" style="display:none;" id="matrixBtn"
					class="updateClass bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 focus:outline-none">Show
					Matrix</button>
				<button onclick="downloadJSON()" style="display:none;" id="downloadBtn"
					class="updateClass bg-yellow-500 text-white px-4 py-2 rounded hover:bg-yellow-600 focus:outline-none">Download
					JSON</button>
				<button onclick="updateDisplay()" style="display:none;" id="updateBtn"
					class="updateClass bg-orange-500 text-white px-4 py-2 rounded hover:bg-orange-600 focus:outline-none">Switch
				</button>
				<button onclick="runAlgorithm(parseInt(document.getElementById('inputValue').value))"
					style="display:none;" id="runAlgorithm"
					class="updateClass bg-pink-500 text-white px-4 py-2 rounded hover:bg-pink-600 focus:outline-none">Run
					Algorithm</button>
				<input type="number" value="1" id="inputValue" class="updateClass border px-2 py-1 rounded max-w-10"
					style="display:none;">

				<input type="checkbox" id="runAllNodes" class="updateClass" style="display:none;" checked>
				<label id="alertsLabel" for="runAllNodes" class="updateClass" style="display:none;">Run All
					Nodes</label>

				<input type="checkbox" id="showAlerts" class="updateClass" style="display:none;" checked>
				<label id="alertsLabel" for="showAlerts" class="updateClass" style="display:none;">Show Alerts</label>

				<input type="checkbox" id="allowPastEdges" class="updateClass" style="display:none;" checked>
				<label id="pastEdgesLabel" for="allowPastEdges" class="updateClass" style="display:none;">Allow Past
					Edges</label>

				<input type="color" id="nodeColorInput" class="updateClass border px-1 py-1 rounded"
					style="display:none;" value="#808080">
				<label for="nodeColorInput" class="updateClass" style="display:none;">Node Color</label>

				<input type="color" id="safeEdgeInput" class="updateClass border px-1 py-1 rounded"
					style="display:none;" value="#9C9C9C">
				<label for="safeEdgeInput" class="updateClass" style="display:none;">Safe Edge Color</label>

				<input type="color" id="unsafeEdgeInput" class="updateClass border px-1 py-1 rounded"
					style="display:none;" value="#9C9C9C">
				<label for="unsafeEdgeInput" class="updateClass" style="display:none;">Unsafe Edge Color</label>
			</div>

			<div class="mt-4">
				<input type="file" id="fileInput" accept=".json" onchange="uploadJSON()"
					class="block w-full text-sm text-gray-500 border border-gray-300 rounded-lg cursor-pointer">
				<button id="uploadBtn" style="display:none;" onclick="uploadJSON()"
					class="mt-2 bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 focus:outline-none">Upload
					JSON</button>
			</div>
		</div>

		<h2 class="text-xl font-semibold mt-6">Generated Graph:</h2>
		<div class="flex items-start">
			<div class="flex-none mr-4">Version: <span id="versionDisplay">1</span></div>

			<div id="matrixContainer" class="flex-grow overflow-x-auto overflow-y-auto max-h-96 mx-4 self-center"
				style="display: none;">
				<table id="graphTable"
					class="min-w-full table-auto border-collapse bg-white shadow-md rounded-lg text-sm">
				</table>
			</div>

			<div class="flex-none ml-auto">
				<button onclick="previous()" id="prev"
					class="bg-purple-500 text-white px-2 py-2 rounded hover:bg-purple-600 focus:outline-none">Prev</button>
				<button onclick="next()" id="next"
					class="bg-purple-500 text-white px-2 py-2 rounded hover:bg-purple-600 focus:outline-none">Next</button>
			</div>
		</div>

		<div id="cy" class="border border-gray-300 mt-6" style="width: auto; height: 600px;"></div>
	</div>

	<div class="offcanvas offcanvas-start !w-[200px]" data-bs-scroll="true" data-bs-backdrop="false" tabindex="-1"
		id="offcanvasScrolling" aria-labelledby="offcanvasScrollingLabel">
		<div class="offcanvas-header">
			<h5 class="offcanvas-title" id="offcanvasScrollingLabel">Node: </h5>
			<button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
		</div>
		<div class="offcanvas-body" id="offBody">
			<p></p>
		</div>
	</div>

	<script>
		let graph = {};
		let version = 1;
		let isMatrixVisible = false; // Track whether the matrix is visible or not
		let dummy = 'circle';
		let noClass = ['weight', 'Past Edges', 'changes'];

		nodeColorInput.addEventListener("change", drawCytoscapeGraph, false);
		safeEdgeInput.addEventListener("change", drawCytoscapeGraph, false);
		unsafeEdgeInput.addEventListener("change", drawCytoscapeGraph, false);

		function updateDisplay() {
			if (dummy == 'grid') {
				dummy = 'circle';
			}
			else {
				dummy = 'grid';
			}
			drawCytoscapeGraph();
		}

		function generateGraph() {
			const numVertices = parseInt(document.getElementById('numVertices').value);
			const weight1 = parseFloat(document.getElementById('weight1').value);
			const weight2 = parseFloat(document.getElementById('weight2').value);
			graph = { version1: {} };
			for (let i = 0; i < numVertices; i++) {
				const vertex = String.fromCharCode(65 + i);
				graph['version' + version][vertex] = { weight: Math.random().toFixed(2) }; //Initialing the object for each vertex.
				graph['version' + version][vertex]['Past Edges'] = [];
			}

			const edgesCount = Array(numVertices).fill(0);
			const maxEdgesPerVertex = 3;
			const totalEdgesNeeded = (numVertices * maxEdgesPerVertex) / 2;

			let edgesCreated = 0;

			while (edgesCreated < totalEdgesNeeded) {
				let sourceIndex = Math.floor(Math.random() * numVertices);
				let destinationIndex;

				let attempts = 0;
				do {
					destinationIndex = Math.floor(Math.random() * numVertices);
					attempts++;
					if (attempts > 100) {
						console.log('Too many attempts to find a valid edge.');
						break;
					}
				} while (
					destinationIndex === sourceIndex || // Prevent self-loops
					edgesCount[sourceIndex] >= maxEdgesPerVertex ||
					edgesCount[destinationIndex] >= maxEdgesPerVertex ||
					graph.version1[String.fromCharCode(65 + sourceIndex)][String.fromCharCode(65 + destinationIndex)]
				);

				if (edgesCount[sourceIndex] < maxEdgesPerVertex && edgesCount[destinationIndex] < maxEdgesPerVertex) {
					const source = String.fromCharCode(65 + sourceIndex);
					const destination = String.fromCharCode(65 + destinationIndex);
					const weight = Math.random() < 0.5 ? weight1 : weight2;

					graph['version' + version][source][destination] = weight;
					graph['version' + version][destination][source] = weight;

					edgesCount[sourceIndex]++;
					edgesCount[destinationIndex]++;
					edgesCreated++;
				}
			}

			// graph['version1']['changes'] = {};
			graph['version1']['changes'] = [];

			refresh();
			$('.updateClass').css('display', 'inline');
		}

		function toggleMatrix() {
			const matrixContainer = document.getElementById('matrixContainer');
			isMatrixVisible = !isMatrixVisible;
			matrixContainer.style.display = isMatrixVisible ? 'block' : 'none';
		}

		function displayGraph() {
			const table = document.getElementById('graphTable');
			table.innerHTML = ''; // Clear previous content

			// Create header row (with an extra cell at the top-left)
			const headerRow = document.createElement('tr');
			headerRow.innerHTML = '<th class="border px-4 py-2 sticky"></th>'; // Top-left empty cell
			for (let i = 0; i < Object.keys(graph['version' + version]).length - 1; i++) {
				headerRow.innerHTML += `<th class="border px-4 py-2 text-center sticky">${String.fromCharCode(65 + i)}</th>`;
			}
			table.appendChild(headerRow);

			// Create rows for each vertex
			for (const [vertex, edges] of Object.entries(graph['version' + version])) {
				if (noClass.includes(vertex))
					continue;
				const row = document.createElement('tr');
				row.innerHTML = `<th class="border px-4 py-2 text-center row-sticky">${vertex}</th>`; // Row header with sticky class
				for (const targetVertex of Object.keys(graph['version' + version])) {
					if (noClass.includes(targetVertex))
						continue;
					else if (vertex === targetVertex) {
						row.innerHTML += '<td class="border px-4 py-2 text-center">x</td>'; // Self-loop indicator
					} else {
						const weight = edges[targetVertex] !== undefined ? edges[targetVertex] : 'x';
						row.innerHTML += `<td class="editable border px-4 py-2 text-center" contenteditable="true" onblur="updateWeight('${vertex}', '${targetVertex}', this.innerText)">${weight}</td>`;
					}
				}
				table.appendChild(row);
			}
		}


		function updateWeight(source, target, newWeight) {
			const weight = parseFloat(newWeight);
			const str = String(newWeight);

			// copy graph
			graph['version' + (version + 1)] = JSON.parse(JSON.stringify(graph['version' + version]));
			version++;

			// update edge
			if (weight === 0 || str.toLowerCase() === 'x') {
				delete graph['version' + version][source][target];
				delete graph['version' + version][target][source];
			} else if (!isNaN(weight) && weight > 0) {
				graph['version' + version][source][target] = weight;
				graph['version' + version][target][source] = weight;
			} else {
				alert("Invalid weight. Please enter a positive number or zero.");
			}

			// update display
			refresh();
			$('#versionDisplay').text(version);
		}


		function drawCytoscapeGraph() {
			const elements = [];
			let nodeColor = $("#nodeColorInput").val();
			let safeEdgeColor = $("#safeEdgeInput").val();
			let unsafeEdgeColor = $("#unsafeEdgeInput").val();

			for (const [source, edges] of Object.entries(graph['version' + version])) {
				if (noClass.includes(source))
					continue;
				elements.push({ data: { id: source, rel: edges.weight } });
				//console.log(edges.weight);
				for (const [destination, weight] of Object.entries(edges)) {
					if (noClass.includes(destination)) {
						continue;
					}
					if (source !== destination) {
						elements.push({ data: { id: destination, rel: graph['version' + version][destination]['weight'] } });
						elements.push({ data: { id: `${source}-${destination}`, source: source, target: destination, label: weight.toFixed(2) } });
					}
				}
			}

			const cy = cytoscape({
				container: document.getElementById('cy'),
				elements: elements,
				style: [
					{
						selector: 'node',
						style: {
							'background-color': nodeColor,
							'label': function (elem) {
								return elem.data('id') + '\n' + elem.data('rel')
							},
							'color': 'green',
							'font-size': '50px',
							'text-wrap': 'wrap'
						}
					},
					{
						selector: 'edge',
						style: {
							'width': 2,
							'line-color': function (elem) {
								let s = graph['version' + version][elem.data('source')]['weight'];
								let t = graph['version' + version][elem.data('target')]['weight'];
								let w = elem.data('label');
								let weightDiff = s > t ? (s - t) : (t - s);
								weightDiff = parseFloat(weightDiff.toFixed(2));

								return weightDiff > w ? unsafeEdgeColor : safeEdgeColor;
							},
							'label': 'data(label)',
							'font-size': '35px',
							'text-justification': 'left',
							'text-margin-x': 5,
							'color': 'red' // Change label color here
						}
					}
				],
				layout: {
					name: dummy,
					avoidOverlap: true,
					nodeOverlap: 0,
					spacingFactor: 3,
					animate: false,

				}
			});

			cy.on('tap', "*", function (evt) {
				var offcanvasElement = document.getElementById('offcanvasScrolling');
				var bsOffcanvas = new bootstrap.Offcanvas(offcanvasElement);
				bsOffcanvas.show();
			});

			cy.on('tap', 'node', function (evt) {
				let text;
				var node = evt.target;
				$('#offBody').text('');
				$('#offcanvasScrollingLabel').html('Node: ' + node.id());
				for (const [destination, weight] of Object.entries(graph['version' + version][node.id()])) {
					text = destination + ': ' + weight;
					$("#offBody").append(text + "<br>");
				}
			});
			cy.on('tap', 'edge', function (evt) {
				let text;
				var edge = evt.target;
				$('#offBody').text('');
				$('#offcanvasScrollingLabel').html('Edge: ' + edge.data('id'));
				$('#offBody').append("Source: " + edge.data('source') + '<br>');
				$('#offBody').append("Destination: " + edge.data('target') + '<br>');
				$('#offBody').append("Weight: " + edge.data('label') + '<br>');
			});
		}

		function downloadJSON() {
			const jsonStr = JSON.stringify(graph, null, 2);
			const blob = new Blob([jsonStr], { type: 'application/json' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = 'graph.json';
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			URL.revokeObjectURL(url);
		}

		function uploadJSON() {
			const fileInput = document.getElementById('fileInput');
			const file = fileInput.files[0];
			if (!file) {
				alert("Please select a file to upload.");
				return;
			}

			const reader = new FileReader();
			reader.onload = function (event) {
				try {
					const json = JSON.parse(event.target.result);
					graph = json;
					version = Object.keys(graph).length;
					document.getElementById('versionDisplay').innerText = version; // Update displayed version
					displayGraph();
					drawCytoscapeGraph();
					$('.updateClass').css('display', 'inline');
				} catch (e) {
					alert("Error parsing JSON: " + e.message);
				}
			};
			reader.readAsText(file);
		}

		function runAlgorithm(number) {
			for (let i = 0; i < number; i++) {
				// run number of simulations on one node at a time
				if (!document.querySelector('#runAllNodes').checked) {
					// Update displayed version
					graph['version' + (version + 1)] = JSON.parse(JSON.stringify(graph['version' + version]));
					version++;
					document.getElementById('versionDisplay').innerText = version;

					// select a random source node
					const nodes = Object.keys(graph['version' + version]).filter(node => node !== 'changes');
					let source;

					do {
						source = nodes[Math.floor(Math.random() * nodes.length)];
					} while (noClass.includes(source));

					// get the edges of the selected source node
					const edges = graph['version' + version][source];

					// select a random target node that does not lead back to the source node
					let target;
					const targetNodes = Object.keys(edges);
					do {
						target = targetNodes[Math.floor(Math.random() * targetNodes.length)];
					} while (
						target === source ||
						noClass.includes(target));

					// find weights of the source and target nodes, and the edge weight
					const sourceWeight = graph['version' + version][source]['weight'];
					const targetWeight = graph['version' + version][target]['weight'];
					const edgeWeight = edges[target];

					// find difference in node opinion and compare with edge weight
					let weightDiff = sourceWeight > targetWeight ? (sourceWeight - targetWeight) : (targetWeight - sourceWeight);
					weightDiff = parseFloat(weightDiff.toFixed(2));
					let newWeight = -1;
					let c = [];

					// update graph
					if (weightDiff > edgeWeight) {
						newWeight = 0;

						if (document.querySelector('#showAlerts').checked)
							alert(`(${sourceWeight}) ${source} --(${edgeWeight})-- ${target} (${targetWeight})\n-->\n(${sourceWeight}) ${source} --(${newWeight})-- ${target} (${targetWeight})`);

						delete graph['version' + version][source][target];
						delete graph['version' + version][target][source];

						let changesString = `${source} -${edgeWeight}- ${target} - broken`;
						c.push(changesString);
						graph['version' + version]['changes'] = c;

						replaceEdge(source, target);
					} else {
						let avg = (parseFloat(sourceWeight) + parseFloat(targetWeight)) / 2;
						avg = avg.toFixed(2);
						graph['version' + version][source]['weight'] = avg;
						graph['version' + version][target]['weight'] = avg;

						// reset changes then update

						let changesString = `${source} ${sourceWeight} & ${target} ${targetWeight} - ${avg}`;
						c.push(changesString);
						graph['version' + version]['changes'] = c;

						if (document.querySelector('#showAlerts').checked)
							alert(`(${sourceWeight}) ${source} --(${edgeWeight})-- ${target} (${targetWeight})\n-->\n(${avg}) ${source} --(${edgeWeight})-- ${target} (${avg})`);
					}
				}
				// run number of simulations on every node in the graph
				else {
					graph['version' + (version + 1)] = JSON.parse(JSON.stringify(graph['version' + version]));
					version++;
					document.getElementById('versionDisplay').innerText = version;

					const nodes = Object.keys(graph['version' + version]).filter(node => node !== 'changes');
					let source;
					let c = [];

					for (const node of nodes) {
						source = node;
						// get the edges of the selected source node
						const edges = graph['version' + version][source];

						// select a random target node that does not lead back to the source node
						let target;
						const targetNodes = Object.keys(edges);
						do {
							target = targetNodes[Math.floor(Math.random() * targetNodes.length)];
						} while (
							target === source ||
							noClass.includes(target));

						// find weights of the source and target nodes, and the edge weight
						const sourceWeight = graph['version' + version][source]['weight'];
						const targetWeight = graph['version' + version][target]['weight'];
						const edgeWeight = edges[target];

						// find difference in node opinion and compare with edge weight
						let weightDiff = sourceWeight > targetWeight ? (sourceWeight - targetWeight) : (targetWeight - sourceWeight);
						weightDiff = parseFloat(weightDiff.toFixed(2));
						let newWeight = -1;

						// update graph
						if (weightDiff > edgeWeight) {
							newWeight = 0;

							if (document.querySelector('#showAlerts').checked)
								alert(`(${sourceWeight}) ${source} --(${edgeWeight})-- ${target} (${targetWeight})\n-->\n(${sourceWeight}) ${source} --(${newWeight})-- ${target} (${targetWeight})`);

							delete graph['version' + version][source][target];
							delete graph['version' + version][target][source];

							let changesString = `${source} -${edgeWeight}- ${target} - broken`;
							c.push(changesString);
							graph['version' + version]['changes'] = c;

							replaceEdge(source, target);
						} else {
							let avg = (parseFloat(sourceWeight) + parseFloat(targetWeight)) / 2;
							avg = avg.toFixed(2);
							graph['version' + version][source]['weight'] = avg;
							graph['version' + version][target]['weight'] = avg;

							// reset changes then update

							let changesString = `${source} ${sourceWeight} & ${target} ${targetWeight} - ${avg}`;
							c.push(changesString);
							graph['version' + version]['changes'] = c;

							if (document.querySelector('#showAlerts').checked)
								alert(`(${sourceWeight}) ${source} --(${edgeWeight})-- ${target} (${targetWeight})\n-->\n(${avg}) ${source} --(${edgeWeight})-- ${target} (${avg})`);
						}
					}
				}
			}

			// update display
			refresh();
		}


		function replaceEdge(source, target) {
			// add source and target to past edges
			// need to add an if statement or something based on checkbox to check past edges for randomly chosen new edge
			let c = graph['version' + version]['changes'];

			let sourceEdges = graph['version' + version][source]['Past Edges'];
			if (!sourceEdges.includes(target)) sourceEdges.push(target);
			graph['version' + version][source]['Past Edges'] = sourceEdges;

			let targetEdges = graph['version' + version][target]['Past Edges'];
			if (!targetEdges.includes(source)) targetEdges.push(source);
			graph['version' + version][target]['Past Edges'] = targetEdges;

			const nodes = Object.keys(graph['version' + version]).filter(node => node !== 'changes');
			let sourceNode, targetNode, changesString, alertString = "";
			let valid = true;

			// get weights from page
			const weight1 = parseFloat(document.getElementById('weight1').value);
			const weight2 = parseFloat(document.getElementById('weight2').value);
			let weightS, weightT, attempts = 100;

			// find source node
			// allow 100 attempts to find valid node based on whether remaking past edges is allowed
			do {
				sourceNode = nodes[Math.floor(Math.random() * nodes.length)];

				// check if source node is in past edges when past edges are not allowed
				if (!document.querySelector('#allowPastEdges').checked && sourceEdges.includes(sourceNode)) {
					attempts++;
					continue; // skip to the next iteration
				}

				// check if the source node is invalid
				if (sourceNode === source || sourceNode === target || graph['version' + version][source][sourceNode]) {
					attempts++;
					if (attempts > 100) {
						console.log("Too many attempts to find valid target vertex (replace edge)");
						changesString = `Failed to make new edge from ${source}`;
						alertString += changesString + '\n';
						c.push(changesString);
						graph['version' + version]['changes'] = c;
						valid = false;
						break;
					}
					continue; // skip to the next iteration if source node not allowed
				}

				// valid source node found
				break;
			} while (true);

			// if source node is valid, create new edge
			if (valid) {
				if (!graph['version' + version][sourceNode]) {
					graph['version' + version][sourceNode] = {};
				}

				// Create the new edge here
				weightS = Math.random() < 0.5 ? weight1 : weight2;
				graph['version' + version][source][sourceNode] = weightS;
				graph['version' + version][sourceNode][source] = weightS;

				changesString = `${source} -${weightS}- ${sourceNode} - made`;
				alertString += changesString + '\n';
				c.push(changesString);
				graph['version' + version]['changes'] = c;
			}

			// repeat for target
			attempts = 0;
			valid = true;

			do {
				targetNode = nodes[Math.floor(Math.random() * nodes.length)];

				if (!document.querySelector('#allowPastEdges').checked && targetEdges.includes(targetNode)) {
					attempts++;
					continue;
				}

				if (targetNode === target || targetNode === source || targetNode === sourceNode || graph['version' + version][target][targetNode]) {
					attempts++;
					if (attempts > 100) {
						console.log("Too many attempts to find valid target vertex (replace edge 2)");
						changesString = `Failed to make new edge from ${target}`;
						alertString += changesString;
						c.push(changesString);
						graph['version' + version]['changes'] = c;
						valid = false;
						break;
					}
					continue;
				}

				break;
			} while (true);

			if (target !== targetNode) {
				if (!graph['version' + version][targetNode]) {
					graph['version' + version][targetNode] = {};
				}

				weightT = Math.random() < 0.5 ? weight1 : weight2;
				graph['version' + version][target][targetNode] = weightT;
				graph['version' + version][targetNode][target] = weightT;

				changesString = `${target} -${weightT}- ${targetNode} - made`;
				alertString += changesString;
				c.push(changesString);
				graph['version' + version]['changes'] = c;
			}

			if (document.querySelector('#showAlerts').checked) {
				alert(alertString);
			}
		}

		function previous() {
			version--;
			if (version > 0) {
				$('#versionDisplay').text(version);
				refresh();
			}
			else {
				version++;
			}
		}

		function next() {
			version++;
			if (version <= Object.keys(graph).length) {
				$('#versionDisplay').text(version);
				refresh();
			}
			else {
				version--;
			}
		}

		function refresh() {
			displayGraph();
			drawCytoscapeGraph();
		}

	</script>

</body>

</html>
